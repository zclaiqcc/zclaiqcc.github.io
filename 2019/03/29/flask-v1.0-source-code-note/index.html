<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="articles for tech &amp; life &amp; thoughts"><title>Flask-v0.1 Source Code Note | Marktub</title><link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Raleway:400,300,600"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Flask-v0.1 Source Code Note</h1><a id="logo" href="/.">Marktub</a><p class="description">Do not go gentle into that good night.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">Flask-v0.1 Source Code Note</h1><div class="post-meta">2019-03-29<span> | </span><span class="category"><a href="/categories/notes/">notes</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#用户端"><span class="toc-number">1.</span> <span class="toc-text">用户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义接口-异常处理"><span class="toc-number">1.1.</span> <span class="toc-text">定义接口&#x2F;异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化运行时的配置"><span class="toc-number">1.2.</span> <span class="toc-text">初始化运行时的配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#服务端"><span class="toc-number">2.</span> <span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加载到服务器运行环境"><span class="toc-number">2.1.</span> <span class="toc-text">加载到服务器运行环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他"><span class="toc-number">3.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#预处理和后处理"><span class="toc-number">3.1.</span> <span class="toc-text">预处理和后处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流程图"><span class="toc-number">4.</span> <span class="toc-text">流程图</span></a></li></ol></div></div><div class="post-content"><p>在阅读之前明确三个问题：</p>
<ol>
<li>flask 是什么？</li>
<li>flask 需要有什么？</li>
<li>为什么要读 v0.1 版本</li>
</ol>
<p><strong><em>暂时不讨论有关  template 渲染相关的问题</em></strong></p>
<p>明确了第一个问题之后第二个其实也就有答案了（可能还没有，这就是为什么需要单独问第二个问题的原因）</p>
<blockquote>
<p>A microframework based on Werkzeug.  It’s extensively documented<br>    and follows best practice patterns.</p>
</blockquote>
<p>flask 是一个基于 <code>Werkzeug</code> 的微框架，那么问题来了，Werkzeug 是什么？Werkzeug 是一个 <code>WSGI</code> 工具包，所以 WSGI 是什么？WSGI（Python Web Server Gateway Interface）是 Python 语言定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口，是一套规范（详情 <a href="https://www.python.org/dev/peps/pep-3333/">PEP3333</a>），所以 Werkzeug 是 WSGI 的实现，也就是说 Werkzeug 是可以直接运行的？是的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.wrappers <span class="keyword">import</span> Request, Response</span><br><span class="line"></span><br><span class="line"><span class="meta">@Request.application</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> Response(<span class="string">'Hello World!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> werkzeug.serving <span class="keyword">import</span> run_simple</span><br><span class="line">    run_simple(<span class="string">'localhost'</span>, <span class="number">4000</span>, application)</span><br></pre></td></tr></table></figure>

<p>所以为什么还需要 flask？（因为没有最懒只有更懒</p>
<p>理解了第一个问题，第二个问题就很明白了：flask 存在于用户层和 GI（Gateway Interface） 层之间，方面用户层编写可读性高的、结构简单（等等特性）的代码，但是 flask 又必须包含服务端框架的基础功能，是一个承上启下的作用。所以 flask 需要具备的功能有：</p>
<ul>
<li>用户端：定义接口，初始化运行时的配置，定义异常处理</li>
<li>服务器端：可以被服务器加载到运行环境中启动，匹配接口并执行相关的处理逻辑，返回结果给请求的客户端</li>
<li>额外的：<ul>
<li>flask 提供了 pre_request 和 after_request 用于对请求进行预处理和后处理</li>
<li>flask 提供了方便的扩展，用户可以完全自定义服务器收到一个请求到准备好返回值这整个之间的所有过程</li>
</ul>
</li>
</ul>
<p>最后一个问题：v0.1 版本首先包含了框架的所有基础功能，而且又不包含太多额外的不需要的功能，方便直接理解要解决的问题的核心。</p>
<p>下面分成 <code>用户端</code>，<code>服务端</code> 和 <code>其他</code> 来分别说明相关内容</p>
<h2 id="用户端"><a href="#用户端" class="headerlink" title="用户端"></a>用户端</h2><h3 id="定义接口-异常处理"><a href="#定义接口-异常处理" class="headerlink" title="定义接口/异常处理"></a>定义接口/异常处理</h3><p>Flask 类中的 <code>route</code> 函数（装饰器）是 flask 定义接口的主要方式，类似的 <code>errorhandler</code> 用于定义异常处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/&lt;username&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_user</span><span class="params">(username)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.errorhandler(404)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_not_found</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'This page does not exist'</span>, <span class="number">404</span></span><br></pre></td></tr></table></figure>

<h3 id="初始化运行时的配置"><a href="#初始化运行时的配置" class="headerlink" title="初始化运行时的配置"></a>初始化运行时的配置</h3><p>flask 主要通过 <code>run</code> 来接收运行时的配置，其实只是把参数传递给 <code>werkzeug</code> 的 <code>run_simple</code>，不过中间截取了 <code>&#39;debug&#39;</code> 这个参数，并填入了 <code>&#39;use_reloader&#39;</code> 和 <code>&#39;use_debugger&#39;</code> 参数（相当于做了一步中间处理）</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="加载到服务器运行环境"><a href="#加载到服务器运行环境" class="headerlink" title="加载到服务器运行环境"></a>加载到服务器运行环境</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, host=<span class="string">'localhost'</span>, port=<span class="number">5000</span>, **options)</span>:</span></span><br><span class="line">    <span class="comment"># 省略中间代码</span></span><br><span class="line">    <span class="keyword">return</span> run_simple(host, port, self, **options)</span><br></pre></td></tr></table></figure>

<p>通过最开始的例子可以看出，<code>werkzeug</code> 的 <code>run_simple</code> 的第三个参数就是服务器在收到客户端请求的时候会执行的函数，这里用了 Python 魔术方法里面的 <code>__call__</code> 方法，让类对象具有可调用的属性，具体来说：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app = Flask()</span><br><span class="line">app()  <span class="comment"># 像调用函数一样调用类对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>``` 方法中直接调用 ``` wsgi_app ``` 函数，那为什么不直接把 ``` self.wsgi_app ``` 作为 ``` run_simple ``` 的参数传进去？在 ``` wsgi_app ``` 的注释中很明确地写出了原因：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; The actual WSGI application.  This is not implemented in &#96;__call__&#96; so that middlewares can be applied:</span><br><span class="line">&gt;</span><br><span class="line">&gt;	    app.wsgi_app &#x3D; MyMiddleware(app.wsgi_app)</span><br><span class="line"></span><br><span class="line">方面用户对 wsgi_app 进行定制化修改（原文：这个函数没有直接定义在 &#96;&#96;&#96; __call__ &#96;&#96;&#96; 中是为了可以应用中间件）</span><br><span class="line"></span><br><span class="line">插一句：Flask 的注释写得确实很清晰明白，经常给出让用户容易理解和尝试的用例和场景</span><br><span class="line"></span><br><span class="line">### 匹配接口并执行相关的处理逻辑&#x2F;返回结果给请求的客户端</span><br><span class="line"></span><br><span class="line">接刚才的 &#96;&#96;&#96; wsgi_app &#96;&#96;&#96; 函数，直接把代码贴出来，因为写得很简洁明了，稍微复杂点的逻辑都抽象成了函数（以后有人问逻辑抽象成函数要抽象到什么程度，就可以把这段代码拿出去）</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">def wsgi_app(self, environ, start_response):</span><br><span class="line">    &quot;&quot;&quot;The actual WSGI application.  This is not implemented in</span><br><span class="line">    &#96;__call__&#96; so that middlewares can be applied:</span><br><span class="line"></span><br><span class="line">        app.wsgi_app &#x3D; MyMiddleware(app.wsgi_app)</span><br><span class="line"></span><br><span class="line">    :param environ: a WSGI environment</span><br><span class="line">    :param start_response: a callable accepting a status code,</span><br><span class="line">                           a list of headers and an optional</span><br><span class="line">                           exception context to start the response</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    with self.request_context(environ):</span><br><span class="line">        rv &#x3D; self.preprocess_request()</span><br><span class="line">        if rv is None:</span><br><span class="line">            rv &#x3D; self.dispatch_request()</span><br><span class="line">        response &#x3D; self.make_response(rv)</span><br><span class="line">        response &#x3D; self.process_response(response)</span><br><span class="line">        return response(environ, start_response)</span><br></pre></td></tr></table></figure>

<p>按行快速读一遍就很爽：</p>
<ol>
<li>加载上下文</li>
<li>预处理</li>
<li>如果预处理没有返回值</li>
<li>分发请求给相关逻辑</li>
<li>准备回复</li>
<li>后处理</li>
<li>回复</li>
</ol>
<p>之前定义的接口在 <code>dispatch_request</code> 中执行，预处理和后处理方法分别在 <code>preprocess_request</code> 和 <code>process_response</code> 中执行，把整个框架的执行逻辑都集中到了这里，并对外提供扩展的可能</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="预处理和后处理"><a href="#预处理和后处理" class="headerlink" title="预处理和后处理"></a>预处理和后处理</h3><figure class="highlight plain"><figcaption><span>``` 和 ``` after_request ``` 两个函数，通过装饰器写法把需要预处理和后处理的方法放到 list 中，后续从 list 从取出函数执行</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### _request_ctx_stack</span><br><span class="line"></span><br><span class="line">flask.py 最下面可以看到如下的几行代码</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line"># context locals</span><br><span class="line">_request_ctx_stack &#x3D; LocalStack()</span><br><span class="line">current_app &#x3D; LocalProxy(lambda: _request_ctx_stack.top.app)</span><br><span class="line">request &#x3D; LocalProxy(lambda: _request_ctx_stack.top.request)</span><br><span class="line">session &#x3D; LocalProxy(lambda: _request_ctx_stack.top.session)</span><br><span class="line">g &#x3D; LocalProxy(lambda: _request_ctx_stack.top.g)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><figcaption><span>``` 是 ``` werkzeug ``` 定义的数据结构，抛开细节不看，总归是个 stack。这里主要说一下 ``` _request_ctx_stack ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在上文 &#96;&#96;&#96; wsgi_app &#96;&#96;&#96; 函数最开始，&#96;&#96;&#96; request_context &#96;&#96;&#96; 函数会创建一个 &#96;&#96;&#96; _RequestContext &#96;&#96;&#96;，并在 &#96;&#96;&#96; __enter__ &#96;&#96;&#96; 方法中把实例本身压栈到了 &#96;&#96;&#96; _request_ctx_stack &#96;&#96;&#96; 中，在 &#96;&#96;&#96; __exit__ &#96;&#96;&#96; 的时候出栈</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">class _RequestContext(object):</span><br><span class="line">	# 省略初始化等中间代码</span><br><span class="line">    def __enter__(self):</span><br><span class="line">        _request_ctx_stack.push(self)</span><br><span class="line"></span><br><span class="line">    def __exit__(self, exc_type, exc_value, tb):</span><br><span class="line">        if tb is None or not self.app.debug:</span><br><span class="line">            _request_ctx_stack.pop()</span><br></pre></td></tr></table></figure>

<p>所以上文的几个全局变量 <code>current_app</code>、<code>request</code>、<code>session</code>、<code>g</code> 其实是栈顶 <code>_RequestContext</code> 实例的属性，也就是当前请求的环境变量，这就是 flask 如何维护上下文的</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://zclaiqcc-1257437822.cos.ap-beijing.myqcloud.com/flask_flow_thumb.jpg" alt="https://zclaiqcc-1257437822.cos.ap-beijing.myqcloud.com/flask_flow.jpg"></p>
</div><div class="tags"><a href="/tags/flask-soruce-code/"><i class="fa fa-tag"></i>flask, soruce-code</a></div><div class="post-nav"><a class="pre" href="/2019/03/29/ES6%20Essentials/">ES6 Essentials</a><a class="next" href="/2019/03/29/wtfpython-cn/">wtfpython Note - CN</a></div></div></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>