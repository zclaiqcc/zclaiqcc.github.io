<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="articles for tech &amp; life &amp; thoughts"><title>Tornado Async Note | Marktub</title><link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Raleway:400,300,600"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.1/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//lib.baomitu.com/clipboard.js/2.0.4/clipboard.min.js"></script><script type="text/javascript" src="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//lib.baomitu.com/toastr.js/2.1.4/toastr.min.css"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Tornado Async Note</h1><a id="logo" href="/.">Marktub</a><p class="description">Do not go gentle into that good night.</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">Tornado Async Note</h1><div class="post-meta">2019-08-24<span> | </span><span class="category"><a href="/categories/notes/">notes</a></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#C10K"><span class="toc-number">1.</span> <span class="toc-text">C10K</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Solutions"><span class="toc-number">2.</span> <span class="toc-text">Solutions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-1-select"><span class="toc-number">2.1.</span> <span class="toc-text">Step 1: select</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-2-poll"><span class="toc-number">2.2.</span> <span class="toc-text">Step 2: poll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Step-3-epoll"><span class="toc-number">2.3.</span> <span class="toc-text">Step 3: epoll</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tornado-Web-Server-Asynchronous"><span class="toc-number">3.</span> <span class="toc-text">Tornado Web Server Asynchronous</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tornado-Web-Server-Starting-Details"><span class="toc-number">4.</span> <span class="toc-text">Tornado Web Server Starting Details</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tornado-Web-Application-Asynchronous-or-Python-Async"><span class="toc-number">5.</span> <span class="toc-text">Tornado Web Application Asynchronous or Python Async</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Referer"><span class="toc-number">6.</span> <span class="toc-text">Referer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最后的最后"><span class="toc-number">7.</span> <span class="toc-text">最后的最后</span></a></li></ol></div></div><div class="post-content"><h2 id="C10K"><a href="#C10K" class="headerlink" title="C10K"></a>C10K</h2><p>10k times of connections at the same time will cause a rapid decreasement of performance of server machine.</p>
<h2 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h2><h3 id="Step-1-select"><a href="#Step-1-select" class="headerlink" title="Step 1: select"></a>Step 1: select</h3><ol>
<li>添加需要监控的文件句柄（file description, fd）到 fd_set</li>
<li>调用 <code>select()</code> 将 fd_set 从用户空间拷贝到内核空间</li>
<li>注册一个回调函数</li>
<li>内核对 fd 进行监控</li>
<li>当满足读/写/超时等条件时调用回调函数并将 fd_set 拷贝回用户空间</li>
<li>轮询查找所有的 fd</li>
<li>当再次有新连接需要监控的时候，重复步骤 1</li>
</ol>
<p><img src="https://zclaiqcc-1257437822.cos.ap-beijing.myqcloud.com/docs-resources/tornado-async/select.jpg" alt="select.jpg"></p>
<p><strong>weakness</strong></p>
<ol>
<li>fd 上限：fd 越多处理效率越低，32 位机默认是 1024</li>
<li>重复初始化：每次都全量地把 fd_set 在用户空间和内核空间来回拷贝</li>
<li>逐个轮询 fd 效率不高：大部分 fd 都是不可操作的（没有状态更新）</li>
</ol>
<h3 id="Step-2-poll"><a href="#Step-2-poll" class="headerlink" title="Step 2: poll"></a>Step 2: poll</h3><p>解决了 fd 上限的问题，用链表存储 fd_set</p>
<h3 id="Step-3-epoll"><a href="#Step-3-epoll" class="headerlink" title="Step 3: epoll"></a>Step 3: epoll</h3><ol>
<li>epoll 提供了 <code>epoll_ctl</code> 函数，用 <code>epoll_ctl</code> 函数进行注册的时候，会将 fd 复制到内核中，不用每次都复制一遍，有新的 fd 时也采用增量拷贝，确保每个 fd 只会被拷贝一次</li>
<li><code>epoll_ctl</code> 函数为每个 fd 注册一个回调函数，同时会在内核汇总通过 <code>epoll_create</code> 创建一个专用链表（还有包含存储 fd 的专用空间），当有 fd 状态发生变更，通过回调函数会将状态发送改变的 fd 加入到该专用链表，<code>epoll_wait</code> 函数负责查看专用链表中有没有就绪的 fd，然后只将就绪的 fd 从内核空间拷贝到用户空间<ul>
<li>epoll_create：用于创建和初始化一些内部使用的数据结构</li>
<li>epoll_crl： 用于注册时间、添加、删除和修改指定的df及其期待的事件</li>
<li>epoll_wait: 用于等待先前指定的fd事件，即就绪的fd</li>
</ul>
</li>
</ol>
<h2 id="Tornado-Web-Server-Asynchronous"><a href="#Tornado-Web-Server-Asynchronous" class="headerlink" title="Tornado Web Server Asynchronous"></a>Tornado Web Server Asynchronous</h2><p><img src="https://zclaiqcc-1257437822.cos.ap-beijing.myqcloud.com/docs-resources/tornado-async/tornado-flow.jpg" alt="tornado-flow.jpg"></p>
<ol>
<li>tornado 会首先建立一个 socket 监听，如果客户端 A 请求建立连接之后，tornado 会基于原先的 socket 新创建一个包含客户端 A 连接有关信息的 socket（分配新的监听端口），原先的 socket 继续监听原来的端口等待建立新的 socket 连接；tornado 把所有的 socket（其实还是文件句柄，fd）都扔给 epoll 去监控；这部分是 tornado web server 负责处理</li>
<li><code>Torando.ioloop.IOLoop.current().start()</code> 开启循环，不断询问 epoll 是否有请求需要处理，这就是 <code>ioloop</code> 所做的工作，也是 tornado 的核心部分；这部分是由 tornado ioloop 负责处理</li>
<li>第一步和第二步是各自独立运行的；当有客户进行请求，epoll 就发现有 socket 可处理，ioloop 再次询问 epoll 时，epoll 就把需要处理的 socket（fd）交给 tornado 处理；最后的处理是由 web app 处理（业务逻辑代码）</li>
</ol>
<p>上面的流程“初步”解决了 C10k 的问题，说“初步”是因为只解决了让客户端的请求进来的问题，但是没有解决处理过程中的阻塞问题，比如 tornado 拿到了 20 个请求需要处理，第一个非常耗时，后面的请求都还是会排队等待，所以需要让 tornado 的处理过程也“异步”起来</p>
<h2 id="Tornado-Web-Server-Starting-Details"><a href="#Tornado-Web-Server-Starting-Details" class="headerlink" title="Tornado Web Server Starting Details"></a>Tornado Web Server Starting Details</h2><p><strong>启动的流程有一些分支，这里不贴全部的代码，只将从零启动一个 server 的所有初始化流程</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_app</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tornado.web.Application([</span><br><span class="line">        (<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app = make_app()</span><br><span class="line">    <span class="comment"># 可以研究一下 Configurable 抽象类是如果定义一个 factory</span></span><br><span class="line">    server = tornado.httpserver.HTTPServer(app)</span><br><span class="line">    <span class="comment"># bind 方法初始化了一个 sockets 对象，但是还并没有调用 `self.add_sockets(sockets)` 添加到 sockets 列表中</span></span><br><span class="line">    <span class="comment"># 而是放到了 `self._pending_sockets` 这个 list 中</span></span><br><span class="line">    server.bind(<span class="number">8888</span>)</span><br><span class="line">    <span class="comment"># 把 `self._pending_sockets` 中预设的 sockets 加载到 server runtime，真正开始 accepting connections</span></span><br><span class="line">    server.start()</span><br><span class="line">    <span class="comment"># app.listen(8888)</span></span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tcpserver.py</span></span><br><span class="line"><span class="comment"># 很多方法都默认写到了 TCPserver，HTTPServer 只是 TCPServer 的子类，大多共用同样的方法，除了 `handle_stream` 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span><span class="params">(object)</span>:</span></span><br><span class="line">	<span class="comment"># `server.start()` 会调用 `self.add_sockets(sockets)` 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_sockets</span><span class="params">(self, sockets: Iterable[socket.socket])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Makes this server start accepting connections on the given sockets.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The ``sockets`` parameter is a list of socket objects such as</span></span><br><span class="line"><span class="string">        those returned by `~tornado.netutil.bind_sockets`.</span></span><br><span class="line"><span class="string">        `add_sockets` is typically used in combination with that</span></span><br><span class="line"><span class="string">        method and `tornado.process.fork_processes` to provide greater</span></span><br><span class="line"><span class="string">        control over the initialization of a multi-process server.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 实际运行的时候发现这里的 sockets 默认是创建了两个，`AddressFamily.AF_INET` 和 `AddressFamily.AF_INET6`, IPv4 和 IPv6</span></span><br><span class="line">        <span class="keyword">for</span> sock <span class="keyword">in</span> sockets:</span><br><span class="line">        	<span class="comment"># `self._sockets` 和 `self._handlers` 只在 `self.stop` 的时候做了一次遍历，把每个注册的 sockets pop 和 close 掉</span></span><br><span class="line">        	<span class="comment"># 重点是这里的 `add_accept_handler(sock, self._handle_connection)` 函数（netutil.py）和 `self._handle_connection` 函数（回调函数）</span></span><br><span class="line">            self._sockets[sock.fileno()] = sock</span><br><span class="line">            <span class="comment"># 不贴工具类 `netutil.add_accept_handler` 的具体代码了</span></span><br><span class="line">            <span class="comment"># 作用是往当前的 ioloop 里面添加一个回调函数是 `self._handle_connection` 的 socket</span></span><br><span class="line">            <span class="comment"># 比较有意思的设计是这里的返回值，这里返回一个函数 `remove_handle`，可以让调用方获得一个可以 revert 当前操作的能力</span></span><br><span class="line">            <span class="comment"># 还有一个细节 `set_close_exec`，是通知调用方执行完毕后 close 掉本次执行</span></span><br><span class="line">            <span class="comment"># IOLoop.READ 是 epoll module 里面的一种 events 类型，具体可查阅 epoll module  </span></span><br><span class="line">            self._handlers[sock.fileno()] = add_accept_handler(</span><br><span class="line">                sock, self._handle_connection</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 回调函数，启动 HTTPServer 注册的 socket 收到连接请求的时候会调用</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_handle_connection</span><span class="params">(self, connection: socket.socket, address: Any)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        [ ... ]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">        	<span class="comment"># 初始化了一个 `iostream`，文档中对这个类的描述是 `Socket-based `IOStream` implementation`</span></span><br><span class="line">        	<span class="comment"># 对 socket 进行异步封装的 IO 数据流处理类</span></span><br><span class="line">        	<span class="comment"># 后面有一段基于 IOStream 类封装的 socket 请求 www.baidu.com 的 Demo</span></span><br><span class="line">            <span class="keyword">if</span> self.ssl_options <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stream = SSLIOStream(</span><br><span class="line">                    connection,</span><br><span class="line">                    max_buffer_size=self.max_buffer_size,</span><br><span class="line">                    read_chunk_size=self.read_chunk_size,</span><br><span class="line">                )  <span class="comment"># type: IOStream</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stream = IOStream(</span><br><span class="line">                    connection,</span><br><span class="line">                    max_buffer_size=self.max_buffer_size,</span><br><span class="line">                    read_chunk_size=self.read_chunk_size,</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 重点是这里的 `self.handle_stream`</span></span><br><span class="line">            <span class="comment"># 把新接受到的 socket 放到 IOStream 中</span></span><br><span class="line">            future = self.handle_stream(stream, address)</span><br><span class="line">            <span class="keyword">if</span> future <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            	<span class="comment"># `gen.convert_yielded(future)` 只是为了把 Python 的 Future 转换成 tornado 自己定义的 Future 类（concurrent.py）</span></span><br><span class="line">                IOLoop.current().add_future(</span><br><span class="line">                    gen.convert_yielded(future), <span class="keyword">lambda</span> f: f.result()</span><br><span class="line">                )</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            app_log.error(<span class="string">"Error in connection callback"</span>, exc_info=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># httpserver.py</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTTPServer</span><span class="params">(TCPServer, Configurable, httputil.HTTPServerConnectionDelegate)</span>:</span></span><br><span class="line">	<span class="string">"""A non-blocking, single-threaded HTTP server.</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle_stream</span><span class="params">(self, stream: iostream.IOStream, address: Tuple)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        context = _HTTPRequestContext(</span><br><span class="line">            stream, address, self.protocol, self.trusted_downstream</span><br><span class="line">        )</span><br><span class="line">        conn = HTTP1ServerConnection(stream, self.conn_params, context)</span><br><span class="line">        self._connections.add(conn)</span><br><span class="line">        conn.start_serving(self)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于 IOStream 类封装的 socket 请求 www.baidu.com 的 Demo</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> tornado.iostream</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, <span class="number">0</span>)</span><br><span class="line">    stream = tornado.iostream.IOStream(s)</span><br><span class="line">    <span class="keyword">await</span> stream.connect((<span class="string">"www.baidu.com"</span>, <span class="number">80</span>))</span><br><span class="line">    <span class="keyword">await</span> stream.write(<span class="string">b"GET / HTTP/1.0\r\nHost: baidu.com\r\n\r\n"</span>)</span><br><span class="line">    header_data = <span class="keyword">await</span> stream.read_until(<span class="string">b"\r\n\r\n"</span>)</span><br><span class="line">    headers = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> header_data.split(<span class="string">b"\r\n"</span>):</span><br><span class="line">        parts = line.split(<span class="string">b":"</span>)</span><br><span class="line">        <span class="keyword">if</span> len(parts) == <span class="number">2</span>:</span><br><span class="line">            headers[parts[<span class="number">0</span>].strip()] = parts[<span class="number">1</span>].strip()</span><br><span class="line">    body_data = <span class="keyword">await</span> stream.read_bytes(int(headers[<span class="string">b"Content-Length"</span>]))</span><br><span class="line">    print(body_data)</span><br><span class="line">    stream.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tornado.ioloop.IOLoop.current().run_sync(main)</span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM, <span class="number">0</span>)</span><br><span class="line">    stream = tornado.iostream.IOStream(s)</span><br><span class="line">    stream.connect((<span class="string">"www.baidu.com"</span>, <span class="number">80</span>), <span class="string">"send_request or something you want to send to the server"</span>)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure>

<h2 id="Tornado-Web-Application-Asynchronous-or-Python-Async"><a href="#Tornado-Web-Application-Asynchronous-or-Python-Async" class="headerlink" title="Tornado Web Application Asynchronous or Python Async"></a>Tornado Web Application Asynchronous or Python Async</h2><p>看一下 <strong>tornado.ioloop.IOLoop.current().start()</strong> 后面都执行了什么，这里强烈推荐执行一个 <code>hello world</code> 代码，一步一步跟踪进去看都执行了哪一步以及属性值都是多少</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello world'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tornado.ioloop.IOLoop.current().run_sync(main)</span><br></pre></td></tr></table></figure>


<p><code>ioloop.py</code> 的 <code>class IOLoop(Configurable)</code> 是基类，Tornado 6.0.3 的 ioloop 直接使用了 Python 的 <code>asyncio</code>，并用 <code>asyncio.BaseAsyncIOLoop</code> 进行封装</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># asyncio.py</span></span><br><span class="line"><span class="comment"># 这里把 IOLoop 基类的方法也放到 BaseAsyncIOLoop 里面，方便阅读</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseAsyncIOLoop</span><span class="params">(IOLoop)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 把 fd 加入到 events 中等待响应</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_handler</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        self, fd: Union[int, _Selectable], handler: Callable[..., None], events: int</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        fd, fileobj = self.split_fd(fd)</span><br><span class="line">        <span class="keyword">if</span> fd <span class="keyword">in</span> self.handlers:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"fd %s added twice"</span> % fd)</span><br><span class="line">        self.handlers[fd] = (fileobj, handler)</span><br><span class="line">        <span class="keyword">if</span> events &amp; IOLoop.READ:</span><br><span class="line">            self.asyncio_loop.add_reader(fd, self._handle_events, fd, IOLoop.READ)</span><br><span class="line">            self.readers.add(fd)</span><br><span class="line">        <span class="keyword">if</span> events &amp; IOLoop.WRITE:</span><br><span class="line">            self.asyncio_loop.add_writer(fd, self._handle_events, fd, IOLoop.WRITE)</span><br><span class="line">            self.writers.add(fd)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取唯一一个 `event_loop`，并执行 run_forever</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            old_loop = asyncio.get_event_loop()</span><br><span class="line">        <span class="keyword">except</span> (RuntimeError, AssertionError):</span><br><span class="line">            old_loop = <span class="literal">None</span>  <span class="comment"># type: ignore</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._setup_logging()</span><br><span class="line">            asyncio.set_event_loop(self.asyncio_loop)</span><br><span class="line">            self.asyncio_loop.run_forever()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            asyncio.set_event_loop(old_loop)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下一个 IOLoop 迭代就执行</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_callback</span><span class="params">(self, callback: Callable, *args: Any, **kwargs: Any)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    	<span class="string">"""Calls the given callback on the next I/O loop iteration.</span></span><br><span class="line"><span class="string">    	"""</span></span><br><span class="line">        <span class="keyword">if</span> get_ident() == self._thread_identity:</span><br><span class="line">            call_soon = self.asyncio_loop.call_soon</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            call_soon = self.asyncio_loop.call_soon_threadsafe</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            call_soon(self._run_callback, functools.partial(callback, *args, **kwargs))</span><br><span class="line">        <span class="keyword">except</span> RuntimeError:</span><br><span class="line">            <span class="comment"># "Event loop is closed". Swallow the exception for</span></span><br><span class="line">            <span class="comment"># consistency with PollIOLoop (and logical consistency</span></span><br><span class="line">            <span class="comment"># with the fact that we can't guarantee that an</span></span><br><span class="line">            <span class="comment"># add_callback that completes without error will</span></span><br><span class="line">            <span class="comment"># eventually execute).</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># IOLoop 基类方法</span></span><br><span class="line">    <span class="comment"># Future finished 的时候才会执行 callback</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_future</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        future: <span class="string">"Union[Future[_T], concurrent.futures.Future[_T]]"</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        callback: Callable[[<span class="string">"Future[_T]"</span>], None],</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Schedules a callback on the ``IOLoop`` when the given</span></span><br><span class="line"><span class="string">        `.Future` is finished.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The callback is invoked with one argument, the</span></span><br><span class="line"><span class="string">        `.Future`.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method only accepts `.Future` objects and not other</span></span><br><span class="line"><span class="string">        awaitables (unlike most of Tornado where the two are</span></span><br><span class="line"><span class="string">        interchangeable).</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(future, Future):</span><br><span class="line">            <span class="comment"># Note that we specifically do not want the inline behavior of</span></span><br><span class="line">            <span class="comment"># tornado.concurrent.future_add_done_callback. We always want</span></span><br><span class="line">            <span class="comment"># this callback scheduled on the next IOLoop iteration (which</span></span><br><span class="line">            <span class="comment"># asyncio.Future always does).</span></span><br><span class="line">            <span class="comment">#</span></span><br><span class="line">            <span class="comment"># Wrap the callback in self._run_callback so we control</span></span><br><span class="line">            <span class="comment"># the error logging (i.e. it goes to tornado.log.app_log</span></span><br><span class="line">            <span class="comment"># instead of asyncio's log).</span></span><br><span class="line">            future.add_done_callback(</span><br><span class="line">                <span class="keyword">lambda</span> f: self._run_callback(functools.partial(callback, future))</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> is_future(future)</span><br><span class="line">            <span class="comment"># For concurrent futures, we use self.add_callback, so</span></span><br><span class="line">            <span class="comment"># it's fine if future_add_done_callback inlines that call.</span></span><br><span class="line">            future_add_done_callback(</span><br><span class="line">                future, <span class="keyword">lambda</span> f: self.add_callback(callback, future)</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># IOLoop 基类方法</span></span><br><span class="line">    <span class="comment"># 立即运行 callback，并且如果 callback 的结果是一个 Future，再通过 add_future 加入到后续执行</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_run_callback</span><span class="params">(self, callback: Callable[[], Any])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Runs a callback with error handling.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        .. versionchanged:: 6.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           CancelledErrors are no longer logged.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            ret = callback()</span><br><span class="line">            <span class="keyword">if</span> ret <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">from</span> tornado <span class="keyword">import</span> gen</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Functions that return Futures typically swallow all</span></span><br><span class="line">                <span class="comment"># exceptions and store them in the Future.  If a Future</span></span><br><span class="line">                <span class="comment"># makes it out to the IOLoop, ensure its exception (if any)</span></span><br><span class="line">                <span class="comment"># gets logged too.</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    ret = gen.convert_yielded(ret)</span><br><span class="line">                <span class="keyword">except</span> gen.BadYieldError:</span><br><span class="line">                    <span class="comment"># It's not unusual for add_callback to be used with</span></span><br><span class="line">                    <span class="comment"># methods returning a non-None and non-yieldable</span></span><br><span class="line">                    <span class="comment"># result, which should just be ignored.</span></span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.add_future(ret, self._discard_future_result)</span><br><span class="line">        <span class="keyword">except</span> asyncio.CancelledError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            app_log.error(<span class="string">"Exception in callback %r"</span>, callback, exc_info=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>


<h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><ul>
<li><a href="https://www.jiqizhixin.com/articles/2019-04-10-15">Tornado原理浅析及应用场景探讨 - 额外概述了 select/poll/epoll</a></li>
<li><a href="https://www.cnblogs.com/yiwenshengmei/archive/2011/06/08/understanding_tornado.html">深入理解Tornado——一个异步web服务器 - 好像是贴了旧版本（6.0 以前）的 Torando.ioloop.IOLoop.current().start() 的代码，可以理解一下原理</a></li>
<li><a href="https://www.rapospectre.com/blog/34">深入理解 tornado 之 底层 ioloop 实现 - 也贴了 iolopp 之前封装 epoll 的代码，最新的直接用 asyncio</a></li>
<li><a href="https://www.youtube.com/watch?v=1coLC-MUCJc">Tulip: Async I/O for Python 3 - Guido Van Rossum</a></li>
<li><a href="https://segmentfault.com/a/1190000004373224#articleHeader2">浅析tornado协程运行原理 - 思路很好，不过有点复杂了，其实直接断点追一下 <code>run_sync</code> 执行 print(‘hello world’) 就可以看到效果</a></li>
<li><a href="http://xidui.github.io/2015/10/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3python3-4-Asyncio%E5%BA%93%E4%B8%8ENode-js%E7%9A%84%E5%BC%82%E6%AD%A5IO%E6%9C%BA%E5%88%B6/">深入理解python3.4中Asyncio库与Node.js的异步IO机制 - 比较硬核，自己尝试写了一个 <code>asyncio.run_forever</code></a></li>
</ul>
<h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p>写完这篇笔记，一步一步调试模式下跟着 IOLoop 处理异步以及 Tornado 接收网络请求（TCPServer/HTTPServer）之后，昨天晚上回家随手翻了一下 《UNIX 网络编程》，发现这两天看的基本都在书里面，也讲了 I/O 复用，之前学的时候就记得一个 server 一个 client 来回打印消息内容，<code>sigh，还是要多读书多看报</code></p>
</div><div class="tags"><a href="/tags/tornado-python-async/"><i class="fa fa-tag"></i>tornado, python, async</a></div><div class="post-nav"><a class="pre" href="/2019/08/24/redis-note/">Redis Note</a><a class="next" href="/2019/08/13/tornado-note/">Tornado Note</a></div></div></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>